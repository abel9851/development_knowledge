### 오늘 배운 것
- nand2teris의 레지스터의 명세를 이해했다.
	- if load(t) then out(t+1) = in(t) , else out(t+1) = out(t)
		- t시점에 load값이 true라면, t+1시점의 out의 값은 t시점의 in의 값이다. t시점의 load값이 0일 경우, t+1시점의 out의 값은 t시점의 out의 값이다.
			- load(t)가 무슨 뜻인지 해깔렸는데 이해가 됬다.  [[레지스터의 명세]]
- fastapi에서 logger.error, warning, info를 사용해서 '명시적'으로 로그를 출력하지 않는다면 액세스 로그만 나온다는 것을 새삼 깨달았다.(access log는 api endpoint + status code형식이다.)

### 오늘 해결한 문제
- access token을 갱신할 때 race condition이 발생했는데(token이 존재하지 않는다는 stale 500에러), SQL alchemy의 with_for_update를 사용해서 비관적인 락으로 변경해서 에러를 해소했다.
	- https://testdriven.io/tips/5ce50ece-eaeb-496f-8339-c871c00781c4/
	- 이 부분은 낙관적인 락으로 해결했었어도 됬다고 생각한다.
		- 낙관적인 락은 비관적인 락보다 동시성이 높다. 충돌시 에러가 발생하니까 이 에러핸들링만 잘하면 문제가 없다고 본다. 한편 비관적인 락은 동시성은 낮지만 충돌이 잦고(선착순 100명 쿠폰), 데이터 정합성이 동시성보다 훨씬 중요할 때(계좌에서 돈을 인출하는 트랜잭션)에 사용하는 방법이니, 일반 웹앱인 경우는 낙관적인 락으로 처리가능하다면 하는게 속도면에서는 좋다고 생각한다.
			- 내일 다시 수정해보자.
- google apps script에서 lambda에 모킹한 데이터를 response받아서 spread sheet에 데이터를 입력했다.
	- google apps script 하나를 사용해서 여러 spread sheet에 재활용하는 방법을 사용하려면 google workspace marketplace를 사용하는 방법만 있는 줄 알았는데 아니었다.
		- template방식(이 경우에는 sheet별 google apps script를 마련하되, 그 sheet는 main처리를 하는 google apps script의 web app url을 부르는 wrapping function으로 사용하도록 한다.)으로 구현해야겠다.
			- add-on방식은 바깥 서버에서 google apps script를 호출할 수 없기 때문에(google workspace marketplace의 사양) 이 방법은 사용하지 않는다.

### 내일 개선할 점
- 리팩토링, 원리가 되는 부분을 파악하자. api의 사용법도 알아야하긴 하지만 그걸 전부 파악하는 것보단, 암기하는 것보단 매번 리팩토링을 하고, 사용하는 기술의 원리, 구조를 스스로 구상하고 파악하고, 그 기술을 선택했을 때의 트레이드오프를 말 할수 있는게 중요하다.

### 생각
- 매일 조금씩이라도 진척이 있으니 기분이 좋다.

### 질문 (궁금한 것)
- 레지스터의 명세를 읽을 때 든 의문점
	- 값을 저장한다는 것은, 입력이 들어왔음에도 불구하고 이전에 출력된(t시점) 출력값이 지금에도(t+1) 유지된다는 것을 의미하나?
		- 레지스터 즉, RAM에 임시 저장하는 로직은 그러하다.
		- disk에 저장하는 방식(에디터의 저장기능, 파일의 저장기능)은 자기 원판(platter)에 헤드(Head)가 접근해서 특정 구역의 자기(N/S극) 방향을 물리적으로 바꾸는 것이라고 한다.
			- 데이터가 자석의 방향으로 새겨지는 것
			- SSD의 경우는 특수하게 설계된 트랜지스터안에 전자를 가두는 방식이라고 한다.


#일일노트